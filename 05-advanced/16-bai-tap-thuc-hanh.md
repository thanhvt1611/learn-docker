# B√†i 16: B√†i T·∫≠p Th·ª±c H√†nh

## üìã M·ª•c Ti√™u

B√†i h·ªçc n√†y cung c·∫•p c√°c b√†i t·∫≠p th·ª±c h√†nh t·ª´ c∆° b·∫£n ƒë·∫øn n√¢ng cao ƒë·ªÉ c·ªßng c·ªë ki·∫øn th·ª©c Docker.

---

## üéØ C·∫•p ƒê·ªô 1: C∆° B·∫£n

### B√†i 1: Hello Docker

**M·ª•c ti√™u:** L√†m quen v·ªõi Docker commands c∆° b·∫£n

**Y√™u c·∫ßu:**
1. Pull image `hello-world`
2. Run container t·ª´ image
3. Xem logs c·ªßa container
4. List t·∫•t c·∫£ containers (bao g·ªìm stopped)
5. Remove container

**H∆∞·ªõng d·∫´n chi ti·∫øt:**

```bash
# B∆∞·ªõc 1: Pull image hello-world
docker pull hello-world
# Output:
# Using default tag: latest
# latest: Pulling from library/hello-world
# ...
# Status: Downloaded newer image for hello-world:latest

# B∆∞·ªõc 2: Verify image ƒë∆∞·ª£c pull
docker images | grep hello-world
# Output: hello-world  latest  ...

# B∆∞·ªõc 3: Run container
docker run hello-world
# Output:
# Hello from Docker!
# This message shows that your installation appears to be working correctly.
# ...

# B∆∞·ªõc 4: List t·∫•t c·∫£ containers (k·ªÉ c·∫£ stopped)
docker ps -a
# Output:
# CONTAINER ID   IMAGE         COMMAND    CREATED         STATUS                     PORTS   NAMES
# a1b2c3d4e5f6   hello-world   "/hello"   10 seconds ago  Exited (0) 9 seconds ago           vibrant_newton

# B∆∞·ªõc 5: Xem logs c·ªßa container
docker logs a1b2c3d4e5f6
# Ho·∫∑c d√πng container name:
docker logs vibrant_newton
# Output: Hello from Docker! ...

# B∆∞·ªõc 6: Get container ID
CONTAINER_ID=$(docker ps -a -q --filter "ancestor=hello-world" | head -1)
echo $CONTAINER_ID

# B∆∞·ªõc 7: Remove container
docker rm $CONTAINER_ID
# Output: container ID

# B∆∞·ªõc 8: Verify container ƒë√£ x√≥a
docker ps -a | grep hello-world
# Output: (tr·ªëng - kh√¥ng c√≥ container)

# B∆∞·ªõc 9: Verify image v·∫´n c√≤n
docker images | grep hello-world
# Output: hello-world v·∫´n c√≥
```

**Ki·ªÉm tra k·∫øt qu·∫£:**
- ‚úÖ Image ƒë∆∞·ª£c pull th√†nh c√¥ng
- ‚úÖ Container ch·∫°y v√† output ƒë√∫ng
- ‚úÖ Container ƒë∆∞·ª£c list
- ‚úÖ Container ƒë∆∞·ª£c remove th√†nh c√¥ng

---

### B√†i 2: Web Server ƒê∆°n Gi·∫£n

**M·ª•c ti√™u:** Ch·∫°y web server v√† expose port

**Y√™u c·∫ßu:**
1. Run Nginx container
2. Expose port 8080 tr√™n host ‚Üí port 80 trong container
3. Truy c·∫≠p http://localhost:8080 ƒë·ªÉ verify
4. Xem logs c·ªßa Nginx
5. Stop v√† remove container

**H∆∞·ªõng d·∫´n chi ti·∫øt:**

```bash
# B∆∞·ªõc 1: Pull nginx:alpine image
docker pull nginx:alpine
# Output: Downloaded newer image for nginx:alpine

# B∆∞·ªõc 2: Run Nginx container
docker run -d -p 8080:80 --name my-nginx nginx:alpine
# -d: Detached mode (ch·∫°y background)
# -p 8080:80: Port mapping (host:container)
# --name my-nginx: ƒê·∫∑t t√™n container
# Output: container ID

# B∆∞·ªõc 3: Verify container ch·∫°y
docker ps
# Output:
# CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS         PORTS                  NAMES
# a1b2c3d4e5f6   nginx:alpine   "/docker-entrypoint.‚Ä¶"   5 seconds ago   Up 4 seconds   0.0.0.0:8080->80/tcp   my-nginx

# B∆∞·ªõc 4: Test web server v·ªõi curl
curl http://localhost:8080
# Output: Nginx welcome page HTML

# B∆∞·ªõc 5: Ho·∫∑c m·ªü browser
# Truy c·∫≠p: http://localhost:8080
# B·∫°n s·∫Ω th·∫•y trang "Welcome to nginx!"

# B∆∞·ªõc 6: Xem logs c·ªßa Nginx
docker logs my-nginx
# Output: Nginx startup logs

# B∆∞·ªõc 7: Follow logs (real-time)
docker logs -f my-nginx
# Output: Logs s·∫Ω update khi c√≥ request
# Ctrl+C ƒë·ªÉ tho√°t

# B∆∞·ªõc 8: Xem chi ti·∫øt container
docker inspect my-nginx | grep -A 5 "PortBindings"
# Output: Port mapping configuration

# B∆∞·ªõc 9: Stop container
docker stop my-nginx
# Output: my-nginx

# B∆∞·ªõc 10: Verify container stopped
docker ps
# Output: (tr·ªëng - my-nginx kh√¥ng ch·∫°y)

# B∆∞·ªõc 11: Verify container v·∫´n t·ªìn t·∫°i (stopped)
docker ps -a | grep my-nginx
# Output: my-nginx v·ªõi status "Exited"

# B∆∞·ªõc 12: Remove container
docker rm my-nginx
# Output: my-nginx

# B∆∞·ªõc 13: Verify container ƒë√£ x√≥a
docker ps -a | grep my-nginx
# Output: (tr·ªëng)
```

**Ki·ªÉm tra k·∫øt qu·∫£:**
- ‚úÖ Nginx container ch·∫°y th√†nh c√¥ng
- ‚úÖ Port mapping ho·∫°t ƒë·ªông (8080 ‚Üí 80)
- ‚úÖ Web server accessible qua http://localhost:8080
- ‚úÖ Logs hi·ªÉn th·ªã ƒë√∫ng
- ‚úÖ Container ƒë∆∞·ª£c stop v√† remove th√†nh c√¥ng

---

### B√†i 3: Custom HTML Page

**M·ª•c ti√™u:** Mount local files v√†o container

**Y√™u c·∫ßu:**
1. T·∫°o file `index.html` v·ªõi n·ªôi dung t√πy √Ω
2. Run Nginx container
3. Mount file `index.html` v√†o `/usr/share/nginx/html/index.html`
4. Truy c·∫≠p v√† verify n·ªôi dung

**H∆∞·ªõng d·∫´n chi ti·∫øt:**

```bash
# B∆∞·ªõc 1: T·∫°o th∆∞ m·ª•c project
mkdir my-website
cd my-website

# B∆∞·ªõc 2: T·∫°o file index.html
cat > index.html << 'EOF'
<!DOCTYPE html>
<html>
<head>
    <title>My Custom Website</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin-top: 50px;
            background-color: #f0f0f0;
        }
        h1 { color: #333; }
        p { color: #666; }
    </style>
</head>
<body>
    <h1>Hello Docker!</h1>
    <p>This is my custom HTML page mounted into Nginx container.</p>
    <p>Current time: <span id="time"></span></p>
    <script>
        document.getElementById('time').textContent = new Date().toLocaleString();
    </script>
</body>
</html>
EOF

# B∆∞·ªõc 3: Verify file ƒë∆∞·ª£c t·∫°o
cat index.html
# Output: HTML content

# B∆∞·ªõc 4: Get current directory path
PWD_PATH=$(pwd)
echo $PWD_PATH
# Output: /path/to/my-website

# B∆∞·ªõc 5: Run Nginx container v·ªõi volume mount
docker run -d \
  -p 8080:80 \
  --name my-website \
  -v $PWD_PATH/index.html:/usr/share/nginx/html/index.html:ro \
  nginx:alpine
# -v: Volume mount
# :ro: Read-only mode
# Output: container ID

# B∆∞·ªõc 6: Verify container ch·∫°y
docker ps | grep my-website
# Output: my-website container

# B∆∞·ªõc 7: Test website
curl http://localhost:8080
# Output: Custom HTML content

# B∆∞·ªõc 8: Ho·∫∑c m·ªü browser
# Truy c·∫≠p: http://localhost:8080
# B·∫°n s·∫Ω th·∫•y "Hello Docker!" v√† custom content

# B∆∞·ªõc 9: Verify volume mount
docker inspect my-website | grep -A 10 "Mounts"
# Output: S·∫Ω th·∫•y volume mount configuration

# B∆∞·ªõc 10: Modify HTML file (test live update)
cat > index.html << 'EOF'
<!DOCTYPE html>
<html>
<head>
    <title>Updated Website</title>
</head>
<body>
    <h1>Updated Content!</h1>
    <p>This file was updated while container is running.</p>
</body>
</html>
EOF

# B∆∞·ªõc 11: Refresh browser ho·∫∑c curl l·∫°i
curl http://localhost:8080
# Output: Updated content (v√¨ volume mount l√† live!)

# B∆∞·ªõc 12: Xem logs
docker logs my-website
# Output: Nginx logs

# B∆∞·ªõc 13: Stop container
docker stop my-website
# Output: my-website

# B∆∞·ªõc 14: Remove container
docker rm my-website
# Output: my-website

# B∆∞·ªõc 15: Verify HTML file v·∫´n c√≤n (volume mount kh√¥ng x√≥a)
cat index.html
# Output: HTML content v·∫´n c√≥
```

**Ki·ªÉm tra k·∫øt qu·∫£:**
- ‚úÖ HTML file ƒë∆∞·ª£c t·∫°o
- ‚úÖ Container ch·∫°y v·ªõi volume mount
- ‚úÖ Custom HTML content hi·ªÉn th·ªã ƒë√∫ng
- ‚úÖ Live update ho·∫°t ƒë·ªông (thay ƒë·ªïi file ‚Üí th·∫•y ngay)
- ‚úÖ Container ƒë∆∞·ª£c stop v√† remove th√†nh c√¥ng
- ‚úÖ HTML file v·∫´n t·ªìn t·∫°i tr√™n host

---

### B√†i 4: Environment Variables

**M·ª•c ti√™u:** S·ª≠ d·ª•ng environment variables

**Y√™u c·∫ßu:**
1. Run PostgreSQL container
2. Set environment variables:
   - POSTGRES_USER=myuser
   - POSTGRES_PASSWORD=mypassword
   - POSTGRES_DB=mydb
3. Verify database ƒë∆∞·ª£c t·∫°o b·∫±ng c√°ch exec v√†o container

**H∆∞·ªõng d·∫´n chi ti·∫øt:**

```bash
# B∆∞·ªõc 1: Run PostgreSQL container v·ªõi environment variables
docker run -d \
  --name postgres \
  -e POSTGRES_USER=myuser \
  -e POSTGRES_PASSWORD=mypassword \
  -e POSTGRES_DB=mydb \
  -p 5432:5432 \
  postgres:15
# -e: Set environment variable
# Output: container ID

# B∆∞·ªõc 2: Verify container ch·∫°y
docker ps | grep postgres
# Output: postgres container

# B∆∞·ªõc 3: Xem logs ƒë·ªÉ confirm PostgreSQL started
docker logs postgres
# T√¨m d√≤ng: "database system is ready to accept connections"

# B∆∞·ªõc 4: Inspect container ƒë·ªÉ xem environment variables
docker inspect postgres | grep -A 20 "Env"
# Output: S·∫Ω th·∫•y POSTGRES_USER, POSTGRES_PASSWORD, POSTGRES_DB

# B∆∞·ªõc 5: Connect v√†o PostgreSQL
docker exec -it postgres psql -U myuser -d mydb
# B√¢y gi·ªù b·∫°n ·ªü trong PostgreSQL shell

# B∆∞·ªõc 6: Verify database (trong psql shell)
\l
# Output: List databases, s·∫Ω th·∫•y "mydb"

# B∆∞·ªõc 7: Verify user (trong psql shell)
\du
# Output: List users, s·∫Ω th·∫•y "myuser"

# B∆∞·ªõc 8: T·∫°o table (trong psql shell)
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name VARCHAR(100),
  email VARCHAR(100)
);

# B∆∞·ªõc 9: Insert data (trong psql shell)
INSERT INTO users (name, email) VALUES ('John Doe', 'john@example.com');
INSERT INTO users (name, email) VALUES ('Jane Smith', 'jane@example.com');

# B∆∞·ªõc 10: Query data (trong psql shell)
SELECT * FROM users;
# Output:
#  id |    name    |       email
# ----+------------+-------------------
#   1 | John Doe   | john@example.com
#   2 | Jane Smith | jane@example.com

# B∆∞·ªõc 11: Tho√°t psql shell
\q

# B∆∞·ªõc 12: Connect l·∫°i t·ª´ host (t·ª´ terminal kh√°c)
docker exec -it postgres psql -U myuser -d mydb -c "SELECT * FROM users;"
# Output: Data v·∫´n c√≤n

# B∆∞·ªõc 13: Test connection t·ª´ host (n·∫øu c√≥ psql client)
psql -h localhost -U myuser -d mydb
# Nh·∫≠p password: mypassword
# B√¢y gi·ªù b·∫°n ·ªü trong PostgreSQL shell

# B∆∞·ªõc 14: Tho√°t
\q

# B∆∞·ªõc 15: Stop container
docker stop postgres
# Output: postgres

# B∆∞·ªõc 16: Remove container
docker rm postgres
# Output: postgres
```

**Ki·ªÉm tra k·∫øt qu·∫£:**
- ‚úÖ PostgreSQL container ch·∫°y th√†nh c√¥ng
- ‚úÖ Environment variables ƒë∆∞·ª£c set ƒë√∫ng
- ‚úÖ Database ƒë∆∞·ª£c t·∫°o v·ªõi t√™n "mydb"
- ‚úÖ User ƒë∆∞·ª£c t·∫°o v·ªõi t√™n "myuser"
- ‚úÖ C√≥ th·ªÉ connect v√†o database
- ‚úÖ C√≥ th·ªÉ t·∫°o table v√† insert data

---

### B√†i 5: Persistent Data

**M·ª•c ti√™u:** S·ª≠ d·ª•ng volumes ƒë·ªÉ persist data

**Y√™u c·∫ßu:**
1. T·∫°o named volume `pgdata`
2. Run PostgreSQL v·ªõi volume
3. T·∫°o table v√† insert data
4. Stop v√† remove container
5. Run l·∫°i container v·ªõi c√πng volume
6. Verify data v·∫´n c√≤n

**H∆∞·ªõng d·∫´n chi ti·∫øt:**

```bash
# B∆∞·ªõc 1: T·∫°o named volume
docker volume create pgdata
# Output: pgdata

# B∆∞·ªõc 2: Verify volume ƒë∆∞·ª£c t·∫°o
docker volume ls | grep pgdata
# Output: pgdata

# B∆∞·ªõc 3: Inspect volume
docker volume inspect pgdata
# Output: Volume configuration

# B∆∞·ªõc 4: Run PostgreSQL container v·ªõi volume
docker run -d \
  --name postgres \
  -e POSTGRES_PASSWORD=secret \
  -e POSTGRES_DB=testdb \
  -v pgdata:/var/lib/postgresql/data \
  postgres:15
# -v pgdata:/var/lib/postgresql/data: Mount volume
# Output: container ID

# B∆∞·ªõc 5: Verify container ch·∫°y
docker ps | grep postgres
# Output: postgres container

# B∆∞·ªõc 6: Xem logs
docker logs postgres
# T√¨m: "database system is ready to accept connections"

# B∆∞·ªõc 7: Connect v√†o PostgreSQL
docker exec -it postgres psql -U postgres -d testdb
# B√¢y gi·ªù b·∫°n ·ªü trong PostgreSQL shell

# B∆∞·ªõc 8: T·∫°o table (trong psql shell)
CREATE TABLE products (
  id SERIAL PRIMARY KEY,
  name VARCHAR(100),
  price DECIMAL(10, 2)
);

# B∆∞·ªõc 9: Insert data (trong psql shell)
INSERT INTO products (name, price) VALUES ('Laptop', 999.99);
INSERT INTO products (name, price) VALUES ('Mouse', 29.99);
INSERT INTO products (name, price) VALUES ('Keyboard', 79.99);

# B∆∞·ªõc 10: Verify data (trong psql shell)
SELECT * FROM products;
# Output:
#  id |   name   | price
# ----+----------+--------
#   1 | Laptop   | 999.99
#   2 | Mouse    |  29.99
#   3 | Keyboard |  79.99

# B∆∞·ªõc 11: Tho√°t psql shell
\q

# B∆∞·ªõc 12: Stop container
docker stop postgres
# Output: postgres

# B∆∞·ªõc 13: Remove container (data v·∫´n gi·ªØ trong volume!)
docker rm postgres
# Output: postgres

# B∆∞·ªõc 14: Verify container ƒë√£ x√≥a
docker ps -a | grep postgres
# Output: (tr·ªëng)

# B∆∞·ªõc 15: Verify volume v·∫´n t·ªìn t·∫°i
docker volume ls | grep pgdata
# Output: pgdata v·∫´n c√≥

# B∆∞·ªõc 16: Run l·∫°i container v·ªõi c√πng volume
docker run -d \
  --name postgres \
  -e POSTGRES_PASSWORD=secret \
  -e POSTGRES_DB=testdb \
  -v pgdata:/var/lib/postgresql/data \
  postgres:15
# Output: container ID (m·ªõi)

# B∆∞·ªõc 17: Verify container ch·∫°y
docker ps | grep postgres
# Output: postgres container (m·ªõi)

# B∆∞·ªõc 18: Connect v√†o PostgreSQL
docker exec -it postgres psql -U postgres -d testdb
# B√¢y gi·ªù b·∫°n ·ªü trong PostgreSQL shell

# B∆∞·ªõc 19: Verify data v·∫´n c√≤n! (trong psql shell)
SELECT * FROM products;
# Output:
#  id |   name   | price
# ----+----------+--------
#   1 | Laptop   | 999.99
#   2 | Mouse    |  29.99
#   3 | Keyboard |  79.99
# üéâ Data v·∫´n c√≤n!

# B∆∞·ªõc 20: Tho√°t psql shell
\q

# B∆∞·ªõc 21: Cleanup
docker stop postgres
docker rm postgres
docker volume rm pgdata
# Output: postgres, pgdata

# B∆∞·ªõc 22: Verify cleanup
docker ps -a | grep postgres
docker volume ls | grep pgdata
# Output: (tr·ªëng)
```

**Ki·ªÉm tra k·∫øt qu·∫£:**
- ‚úÖ Named volume ƒë∆∞·ª£c t·∫°o
- ‚úÖ PostgreSQL container ch·∫°y v·ªõi volume
- ‚úÖ Table v√† data ƒë∆∞·ª£c t·∫°o
- ‚úÖ Container ƒë∆∞·ª£c stop v√† remove
- ‚úÖ Volume v·∫´n t·ªìn t·∫°i
- ‚úÖ Container m·ªõi ch·∫°y v·ªõi c√πng volume
- ‚úÖ Data v·∫´n c√≤n sau khi container ƒë∆∞·ª£c remove!

**Bonus - Backup volume:**

```bash
# Backup volume data
docker run --rm -v pgdata:/data -v $(pwd):/backup \
  alpine tar czf /backup/pgdata-backup.tar.gz -C /data .

# Restore volume data
docker run --rm -v pgdata:/data -v $(pwd):/backup \
  alpine tar xzf /backup/pgdata-backup.tar.gz -C /data
```

---

## üöÄ C·∫•p ƒê·ªô 2: Trung B√¨nh

### B√†i 6: Build Custom Image

**M·ª•c ti√™u:** T·∫°o Dockerfile v√† build image

**Y√™u c·∫ßu:**
1. T·∫°o Node.js app ƒë∆°n gi·∫£n (Express server)
2. Vi·∫øt Dockerfile
3. Build image v·ªõi tag `myapp:1.0`
4. Run container t·ª´ image
5. Test API endpoint

**H∆∞·ªõng d·∫´n chi ti·∫øt:**

```bash
# B∆∞·ªõc 1: T·∫°o th∆∞ m·ª•c project
mkdir my-app
cd my-app

# B∆∞·ªõc 2: T·∫°o package.json
cat > package.json << 'EOF'
{
  "name": "my-app",
  "version": "1.0.0",
  "main": "app.js",
  "scripts": {
    "start": "node app.js"
  },
  "dependencies": {
    "express": "^4.18.2"
  }
}
EOF

# B∆∞·ªõc 3: T·∫°o app.js
cat > app.js << 'EOF'
const express = require('express');
const app = express();

app.get('/', (req, res) => {
  res.json({ message: 'Hello from Docker!' });
});

app.get('/health', (req, res) => {
  res.json({ status: 'healthy' });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
EOF

# B∆∞·ªõc 4: T·∫°o Dockerfile
cat > Dockerfile << 'EOF'
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
EXPOSE 3000
CMD ["node", "app.js"]
EOF

# B∆∞·ªõc 5: T·∫°o .dockerignore
cat > .dockerignore << 'EOF'
node_modules
npm-debug.log
.git
.env
EOF

# B∆∞·ªõc 6: Verify files
ls -la
# Output: package.json, app.js, Dockerfile, .dockerignore

# B∆∞·ªõc 7: Build image
docker build -t myapp:1.0 .
# Output:
# Sending build context to Docker daemon  ...
# Step 1/6 : FROM node:18-alpine
# ...
# Successfully tagged myapp:1.0

# B∆∞·ªõc 8: Verify image ƒë∆∞·ª£c t·∫°o
docker images | grep myapp
# Output: myapp  1.0  ...

# B∆∞·ªõc 9: Inspect image
docker inspect myapp:1.0 | grep -A 5 "Cmd"
# Output: CMD ["node", "app.js"]

# B∆∞·ªõc 10: Run container
docker run -d -p 3000:3000 --name my-app-container myapp:1.0
# Output: container ID

# B∆∞·ªõc 11: Verify container ch·∫°y
docker ps | grep my-app-container
# Output: my-app-container

# B∆∞·ªõc 12: Xem logs
docker logs my-app-container
# Output: Server running on port 3000

# B∆∞·ªõc 13: Test API endpoint 1
curl http://localhost:3000
# Output: {"message":"Hello from Docker!"}

# B∆∞·ªõc 14: Test API endpoint 2
curl http://localhost:3000/health
# Output: {"status":"healthy"}

# B∆∞·ªõc 15: Test v·ªõi jq (pretty print)
curl http://localhost:3000 | jq .
# Output:
# {
#   "message": "Hello from Docker!"
# }

# B∆∞·ªõc 16: Xem resource usage
docker stats my-app-container --no-stream
# Output: CPU, Memory usage

# B∆∞·ªõc 17: Exec v√†o container
docker exec -it my-app-container sh
# B√¢y gi·ªù b·∫°n ·ªü trong container shell

# B∆∞·ªõc 18: Trong container, check Node version
node --version
# Output: v18.x.x

# B∆∞·ªõc 19: Tho√°t container
exit

# B∆∞·ªõc 20: Stop container
docker stop my-app-container
# Output: my-app-container

# B∆∞·ªõc 21: Remove container
docker rm my-app-container
# Output: my-app-container

# B∆∞·ªõc 22: Verify image v·∫´n c√≤n
docker images | grep myapp
# Output: myapp:1.0 v·∫´n c√≥
```

**Ki·ªÉm tra k·∫øt qu·∫£:**
- ‚úÖ Node.js app ƒë∆∞·ª£c t·∫°o
- ‚úÖ Dockerfile ƒë∆∞·ª£c t·∫°o ƒë√∫ng
- ‚úÖ Image build th√†nh c√¥ng
- ‚úÖ Container ch·∫°y t·ª´ image
- ‚úÖ API endpoints ho·∫°t ƒë·ªông
- ‚úÖ Logs hi·ªÉn th·ªã ƒë√∫ng

**Bonus - Tag v√† push image:**

```bash
# Tag image v·ªõi Docker Hub username
docker tag myapp:1.0 username/myapp:1.0

# Login v√†o Docker Hub
docker login

# Push image
docker push username/myapp:1.0

# Verify push
docker images | grep username/myapp
```

---

### B√†i 7: Multi-Container v·ªõi Networks

**M·ª•c ti√™u:** K·∫øt n·ªëi nhi·ªÅu containers qua network

**Y√™u c·∫ßu:**
1. T·∫°o custom network `mynetwork`
2. Run PostgreSQL container tr√™n network
3. Run Node.js API container tr√™n c√πng network
4. API connect ƒë·∫øn PostgreSQL qua hostname
5. Verify connection

**H∆∞·ªõng d·∫´n chi ti·∫øt:**

```bash
# B∆∞·ªõc 1: T·∫°o custom network
docker network create mynetwork
# Output: network ID

# B∆∞·ªõc 2: Verify network ƒë∆∞·ª£c t·∫°o
docker network ls | grep mynetwork
# Output: mynetwork

# B∆∞·ªõc 3: Inspect network
docker network inspect mynetwork
# Output: Network configuration (tr·ªëng - ch∆∞a c√≥ containers)

# B∆∞·ªõc 4: Run PostgreSQL container tr√™n network
docker run -d \
  --name postgres \
  --network mynetwork \
  -e POSTGRES_PASSWORD=secret \
  -e POSTGRES_DB=mydb \
  postgres:15
# Output: container ID

# B∆∞·ªõc 5: Verify PostgreSQL container ch·∫°y
docker ps | grep postgres
# Output: postgres container

# B∆∞·ªõc 6: Xem logs
docker logs postgres
# T√¨m: "database system is ready to accept connections"

# B∆∞·ªõc 7: T·∫°o Node.js API app
mkdir my-api
cd my-api

# B∆∞·ªõc 8: T·∫°o package.json
cat > package.json << 'EOF'
{
  "name": "my-api",
  "version": "1.0.0",
  "main": "app.js",
  "dependencies": {
    "express": "^4.18.2",
    "pg": "^8.10.0"
  }
}
EOF

# B∆∞·ªõc 9: T·∫°o app.js
cat > app.js << 'EOF'
const express = require('express');
const { Client } = require('pg');

const app = express();

// PostgreSQL connection
const client = new Client({
  user: 'postgres',
  password: 'secret',
  host: 'postgres',  // ‚Üê Hostname c·ªßa PostgreSQL container
  port: 5432,
  database: 'mydb'
});

client.connect();

app.get('/', (req, res) => {
  res.json({ message: 'Hello from API!' });
});

app.get('/db-test', async (req, res) => {
  try {
    const result = await client.query('SELECT NOW()');
    res.json({
      message: 'Connected to PostgreSQL!',
      timestamp: result.rows[0].now
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`API running on port ${PORT}`);
});
EOF

# B∆∞·ªõc 10: T·∫°o Dockerfile
cat > Dockerfile << 'EOF'
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
EXPOSE 3000
CMD ["node", "app.js"]
EOF

# B∆∞·ªõc 11: Build API image
docker build -t my-api:1.0 .
# Output: Successfully tagged my-api:1.0

# B∆∞·ªõc 12: Run API container tr√™n c√πng network
docker run -d \
  --name api \
  --network mynetwork \
  -p 3000:3000 \
  -e DATABASE_URL=postgresql://postgres:secret@postgres:5432/mydb \
  my-api:1.0
# Output: container ID

# B∆∞·ªõc 13: Verify API container ch·∫°y
docker ps | grep api
# Output: api container

# B∆∞·ªõc 14: Xem logs
docker logs api
# Output: API running on port 3000

# B∆∞·ªõc 15: Inspect network ƒë·ªÉ xem containers
docker network inspect mynetwork
# Output: S·∫Ω th·∫•y 2 containers (postgres, api)

# B∆∞·ªõc 16: Test API endpoint 1
curl http://localhost:3000
# Output: {"message":"Hello from API!"}

# B∆∞·ªõc 17: Test API endpoint 2 (database connection)
curl http://localhost:3000/db-test
# Output: {"message":"Connected to PostgreSQL!","timestamp":"..."}
# üéâ API connected to PostgreSQL!

# B∆∞·ªõc 18: Test network connectivity t·ª´ API container
docker exec api ping -c 1 postgres
# Output: PING postgres ... (th√†nh c√¥ng!)

# B∆∞·ªõc 19: Test network connectivity t·ª´ PostgreSQL container
docker exec postgres ping -c 1 api
# Output: PING api ... (th√†nh c√¥ng!)

# B∆∞·ªõc 20: Xem network interfaces
docker exec api ip addr
# Output: Network configuration

# B∆∞·ªõc 21: Xem DNS resolution
docker exec api nslookup postgres
# Output: postgres resolves to IP address

# B∆∞·ªõc 22: Stop containers
docker stop api postgres
# Output: api, postgres

# B∆∞·ªõc 23: Remove containers
docker rm api postgres
# Output: api, postgres

# B∆∞·ªõc 24: Remove network
docker network rm mynetwork
# Output: mynetwork

# B∆∞·ªõc 25: Verify cleanup
docker ps -a | grep -E "api|postgres"
docker network ls | grep mynetwork
# Output: (tr·ªëng)
```

**Ki·ªÉm tra k·∫øt qu·∫£:**
- ‚úÖ Custom network ƒë∆∞·ª£c t·∫°o
- ‚úÖ PostgreSQL container ch·∫°y tr√™n network
- ‚úÖ API container ch·∫°y tr√™n c√πng network
- ‚úÖ API c√≥ th·ªÉ connect ƒë·∫øn PostgreSQL qua hostname
- ‚úÖ Containers c√≥ th·ªÉ ping nhau
- ‚úÖ DNS resolution ho·∫°t ƒë·ªông

**Bonus - Docker Compose version:**

```bash
# T·∫°o docker-compose.yml
cat > docker-compose.yml << 'EOF'
version: '3.8'

services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_PASSWORD: secret
      POSTGRES_DB: mydb
    networks:
      - mynetwork

  api:
    build: .
    ports:
      - "3000:3000"
    environment:
      DATABASE_URL: postgresql://postgres:secret@postgres:5432/mydb
    depends_on:
      - postgres
    networks:
      - mynetwork

networks:
  mynetwork:
EOF

# Run v·ªõi docker-compose
docker compose up -d

# Test
curl http://localhost:3000/db-test

# Cleanup
docker compose down
```

---

### B√†i 8: Docker Compose - WordPress

**M·ª•c ti√™u:** Deploy WordPress v·ªõi Docker Compose

**Y√™u c·∫ßu:**
1. T·∫°o `docker-compose.yml`
2. Services: WordPress + MySQL
3. Persistent volumes cho c·∫£ 2 services
4. Custom network
5. Deploy v√† access WordPress

**H∆∞·ªõng d·∫´n chi ti·∫øt:**

```bash
# B∆∞·ªõc 1: T·∫°o th∆∞ m·ª•c project
mkdir wordpress-app
cd wordpress-app

# B∆∞·ªõc 2: T·∫°o docker-compose.yml
cat > docker-compose.yml << 'EOF'
version: '3.8'

services:
  db:
    image: mysql:8.0
    restart: unless-stopped
    environment:
      MYSQL_ROOT_PASSWORD: rootpass
      MYSQL_DATABASE: wordpress
      MYSQL_USER: wpuser
      MYSQL_PASSWORD: wppass
    volumes:
      - db-data:/var/lib/mysql
    networks:
      - wordpress-net
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      interval: 10s
      timeout: 5s
      retries: 5

  wordpress:
    image: wordpress:latest
    restart: unless-stopped
    ports:
      - "8080:80"
    environment:
      WORDPRESS_DB_HOST: db:3306
      WORDPRESS_DB_USER: wpuser
      WORDPRESS_DB_PASSWORD: wppass
      WORDPRESS_DB_NAME: wordpress
    volumes:
      - wp-data:/var/www/html
    depends_on:
      db:
        condition: service_healthy
    networks:
      - wordpress-net

volumes:
  db-data:
  wp-data:

networks:
  wordpress-net:
EOF

# B∆∞·ªõc 3: Verify docker-compose.yml
cat docker-compose.yml

# B∆∞·ªõc 4: Start services
docker compose up -d
# Output:
# Creating network "wordpress-app_wordpress-net" with the default driver
# Creating volume "wordpress-app_db-data" with default driver
# Creating volume "wordpress-app_wp-data" with default driver
# Creating wordpress-app-db-1 ... done
# Creating wordpress-app-wordpress-1 ... done

# B∆∞·ªõc 5: Verify services ch·∫°y
docker compose ps
# Output:
# NAME                      COMMAND                  SERVICE      STATUS
# wordpress-app-db-1        "docker-entrypoint.s‚Ä¶"   db           Up 10 seconds (healthy)
# wordpress-app-wordpress-1 "docker-entrypoint.s‚Ä¶"   wordpress    Up 5 seconds

# B∆∞·ªõc 6: Xem logs
docker compose logs
# Output: Logs t·ª´ c·∫£ 2 services

# B∆∞·ªõc 7: Follow logs (real-time)
docker compose logs -f
# Ctrl+C ƒë·ªÉ tho√°t

# B∆∞·ªõc 8: Xem logs c·ªßa service c·ª• th·ªÉ
docker compose logs db
docker compose logs wordpress

# B∆∞·ªõc 9: Verify volumes ƒë∆∞·ª£c t·∫°o
docker volume ls | grep wordpress-app
# Output: wordpress-app_db-data, wordpress-app_wp-data

# B∆∞·ªõc 10: Verify network ƒë∆∞·ª£c t·∫°o
docker network ls | grep wordpress-app
# Output: wordpress-app_wordpress-net

# B∆∞·ªõc 11: Inspect network
docker network inspect wordpress-app_wordpress-net
# Output: S·∫Ω th·∫•y 2 containers k·∫øt n·ªëi

# B∆∞·ªõc 12: Access WordPress
# M·ªü browser: http://localhost:8080
# B·∫°n s·∫Ω th·∫•y WordPress setup page

# B∆∞·ªõc 13: Setup WordPress (trong browser)
# - Language: English
# - Site Title: My Blog
# - Username: admin
# - Password: password123
# - Email: admin@example.com
# - Click "Install WordPress"

# B∆∞·ªõc 14: Login v√†o WordPress
# URL: http://localhost:8080/wp-login.php
# Username: admin
# Password: password123

# B∆∞·ªõc 15: Verify database connection
docker compose exec db mysql -u wpuser -pwppass wordpress -e "SELECT * FROM wp_users;"
# Output: WordPress users table

# B∆∞·ªõc 16: Verify volumes c√≥ data
docker volume inspect wordpress-app_db-data
# Output: Mountpoint s·∫Ω ch·ª©a MySQL data

# B∆∞·ªõc 17: Stop services (data v·∫´n gi·ªØ)
docker compose stop
# Output: Stopping services

# B∆∞·ªõc 18: Verify services stopped
docker compose ps
# Output: Services v·ªõi status "Exited"

# B∆∞·ªõc 19: Start l·∫°i services
docker compose start
# Output: Starting services

# B∆∞·ªõc 20: Verify data v·∫´n c√≤n
# M·ªü browser: http://localhost:8080
# WordPress v·∫´n c√≥ data!

# B∆∞·ªõc 21: Scale services (n√¢ng cao)
docker compose up -d --scale wordpress=2
# Output: 2 WordPress instances

# B∆∞·ªõc 22: Verify
docker compose ps
# Output: 2 WordPress containers

# B∆∞·ªõc 23: Cleanup (x√≥a containers nh∆∞ng gi·ªØ volumes)
docker compose stop
docker compose rm
# Output: Containers removed

# B∆∞·ªõc 24: Verify volumes v·∫´n c√≤n
docker volume ls | grep wordpress-app
# Output: Volumes v·∫´n c√≥

# B∆∞·ªõc 25: Cleanup ho√†n to√†n (x√≥a c·∫£ volumes)
docker compose down -v
# Output: Containers, networks, volumes removed

# B∆∞·ªõc 26: Verify cleanup
docker compose ps
docker volume ls | grep wordpress-app
docker network ls | grep wordpress-app
# Output: (tr·ªëng)
```

**Ki·ªÉm tra k·∫øt qu·∫£:**
- ‚úÖ docker-compose.yml ƒë∆∞·ª£c t·∫°o ƒë√∫ng
- ‚úÖ Services start th√†nh c√¥ng
- ‚úÖ MySQL database ch·∫°y
- ‚úÖ WordPress ch·∫°y
- ‚úÖ Volumes ƒë∆∞·ª£c t·∫°o
- ‚úÖ Network ƒë∆∞·ª£c t·∫°o
- ‚úÖ WordPress accessible qua http://localhost:8080
- ‚úÖ Data persist sau khi stop/start
- ‚úÖ Cleanup ho·∫°t ƒë·ªông

**Bonus - Th√™m Nginx reverse proxy:**

```yaml
version: '3.8'

services:
  db:
    image: mysql:8.0
    # ... (nh∆∞ tr√™n)

  wordpress:
    image: wordpress:latest
    # ... (nh∆∞ tr√™n)
    expose:
      - "80"  # Kh√¥ng expose port, ch·ªâ cho nginx access

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - wordpress
    networks:
      - wordpress-net

volumes:
  db-data:
  wp-data:

networks:
  wordpress-net:
```

---

### B√†i 9: Multi-Stage Build

**M·ª•c ti√™u:** Optimize image size v·ªõi multi-stage build

**Y√™u c·∫ßu:**
1. T·∫°o React app
2. Vi·∫øt Dockerfile v·ªõi multi-stage build
3. Stage 1: Build app
4. Stage 2: Serve v·ªõi Nginx
5. So s√°nh image size

**H∆∞·ªõng d·∫´n chi ti·∫øt:**

```bash
# B∆∞·ªõc 1: T·∫°o th∆∞ m·ª•c project
mkdir react-app
cd react-app

# B∆∞·ªõc 2: T·∫°o package.json
cat > package.json << 'EOF'
{
  "name": "react-app",
  "version": "1.0.0",
  "private": true,
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-scripts": "5.0.1"
  },
  "scripts": {
    "build": "react-scripts build",
    "start": "react-scripts start"
  },
  "eslintConfig": {
    "extends": ["react-app"]
  },
  "browserslist": {
    "production": [">0.2%", "not dead", "not op_mini all"],
    "development": ["last 1 chrome version"]
  }
}
EOF

# B∆∞·ªõc 3: T·∫°o public/index.html
mkdir -p public
cat > public/index.html << 'EOF'
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>React App</title>
</head>
<body>
    <div id="root"></div>
</body>
</html>
EOF

# B∆∞·ªõc 4: T·∫°o src/index.js
mkdir -p src
cat > src/index.js << 'EOF'
import React from 'react';
import ReactDOM from 'react-dom/client';

const App = () => (
  <div style={{ textAlign: 'center', marginTop: '50px', fontFamily: 'Arial' }}>
    <h1>Hello from React in Docker!</h1>
    <p>This is a multi-stage build example.</p>
    <p>Image size is optimized!</p>
  </div>
);

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
EOF

# B∆∞·ªõc 5: T·∫°o .dockerignore
cat > .dockerignore << 'EOF'
node_modules
npm-debug.log
build
.git
.env
.DS_Store
EOF

# B∆∞·ªõc 6: T·∫°o Dockerfile v·ªõi multi-stage build
cat > Dockerfile << 'EOF'
# ===== Stage 1: Build =====
FROM node:18-alpine AS builder

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm ci

# Copy source code
COPY . .

# Build app
RUN npm run build

# ===== Stage 2: Production =====
FROM nginx:alpine

# Copy built files t·ª´ stage 1
COPY --from=builder /app/build /usr/share/nginx/html

# Copy nginx config
RUN echo 'server { \
  listen 80; \
  location / { \
    root /usr/share/nginx/html; \
    try_files $uri /index.html; \
  } \
}' > /etc/nginx/conf.d/default.conf

# Expose port
EXPOSE 80

# Start nginx
CMD ["nginx", "-g", "daemon off;"]
EOF

# B∆∞·ªõc 7: Verify files
ls -la
# Output: package.json, src/, public/, Dockerfile, .dockerignore

# B∆∞·ªõc 8: Build image
docker build -t react-app:1.0 .
# Output: Successfully tagged react-app:1.0
# L∆∞u √Ω: Build s·∫Ω m·∫•t v√†i ph√∫t

# B∆∞·ªõc 9: Xem image size
docker images | grep react-app
# Output: react-app  1.0  ...  ~50MB

# B∆∞·ªõc 10: Xem layers c·ªßa image
docker history react-app:1.0
# Output: S·∫Ω th·∫•y 2 stages

# B∆∞·ªõc 11: T·∫°o Dockerfile single-stage ƒë·ªÉ so s√°nh
cat > Dockerfile.single << 'EOF'
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build
EXPOSE 80
CMD ["npm", "start"]
EOF

# B∆∞·ªõc 12: Build single-stage image
docker build -f Dockerfile.single -t react-app:single .
# Output: Successfully tagged react-app:single

# B∆∞·ªõc 13: So s√°nh image size
docker images | grep react-app
# Output:
# react-app  1.0      ...  ~50MB   (multi-stage)
# react-app  single   ...  ~500MB  (single-stage)
# Multi-stage nh·ªè h∆°n 10 l·∫ßn!

# B∆∞·ªõc 14: Run multi-stage image
docker run -d -p 8080:80 --name react-app-multi react-app:1.0
# Output: container ID

# B∆∞·ªõc 15: Verify container ch·∫°y
docker ps | grep react-app-multi
# Output: react-app-multi

# B∆∞·ªõc 16: Test app
curl http://localhost:8080
# Output: HTML content

# Ho·∫∑c m·ªü browser: http://localhost:8080

# B∆∞·ªõc 17: Run single-stage image
docker run -d -p 8081:80 --name react-app-single react-app:single
# Output: container ID

# B∆∞·ªõc 18: Test single-stage app
curl http://localhost:8081
# Output: HTML content

# B∆∞·ªõc 19: So s√°nh resource usage
docker stats --no-stream
# Output: CPU, Memory c·ªßa c·∫£ 2 containers
# Multi-stage s·∫Ω nh·ªè h∆°n

# B∆∞·ªõc 20: Inspect multi-stage image
docker inspect react-app:1.0 | grep -A 5 "RootFS"
# Output: Layers information

# B∆∞·ªõc 21: Inspect single-stage image
docker inspect react-app:single | grep -A 5 "RootFS"
# Output: Layers information (nhi·ªÅu h∆°n)

# B∆∞·ªõc 22: Stop containers
docker stop react-app-multi react-app-single
# Output: container names

# B∆∞·ªõc 23: Remove containers
docker rm react-app-multi react-app-single
# Output: container names

# B∆∞·ªõc 24: Remove images
docker rmi react-app:1.0 react-app:single
# Output: image IDs

# B∆∞·ªõc 25: Verify cleanup
docker images | grep react-app
# Output: (tr·ªëng)
```

**Ki·ªÉm tra k·∫øt qu·∫£:**
- ‚úÖ React app ƒë∆∞·ª£c t·∫°o
- ‚úÖ Dockerfile multi-stage ƒë∆∞·ª£c t·∫°o
- ‚úÖ Image build th√†nh c√¥ng
- ‚úÖ Multi-stage image nh·ªè h∆°n single-stage
- ‚úÖ App ch·∫°y ƒë√∫ng
- ‚úÖ Resource usage t·ªëi ∆∞u

**Bonus - Analyze image layers:**

```bash
# S·ª≠ d·ª•ng dive ƒë·ªÉ analyze image
docker run --rm -it \
  -v /var/run/docker.sock:/var/run/docker.sock \
  wagoodman/dive:latest react-app:1.0

# Ho·∫∑c s·ª≠ d·ª•ng docker history
docker history react-app:1.0 --no-trunc

# Ho·∫∑c s·ª≠ d·ª•ng docker inspect
docker inspect react-app:1.0 --format='{{json .RootFS.Layers}}' | jq .
```

---

### B√†i 10: Health Checks

**M·ª•c ti√™u:** Implement health checks

**Y√™u c·∫ßu:**
1. T·∫°o API v·ªõi `/health` endpoint
2. Th√™m HEALTHCHECK v√†o Dockerfile
3. Build v√† run container
4. Verify health status

**H∆∞·ªõng d·∫´n chi ti·∫øt:**

```bash
# B∆∞·ªõc 1: T·∫°o th∆∞ m·ª•c project
mkdir health-check-app
cd health-check-app

# B∆∞·ªõc 2: T·∫°o package.json
cat > package.json << 'EOF'
{
  "name": "health-check-app",
  "version": "1.0.0",
  "main": "server.js",
  "dependencies": {
    "express": "^4.18.2"
  }
}
EOF

# B∆∞·ªõc 3: T·∫°o server.js
cat > server.js << 'EOF'
const express = require('express');
const app = express();

let isHealthy = true;

app.get('/', (req, res) => {
  res.json({ message: 'Hello from API!' });
});

app.get('/health', (req, res) => {
  if (isHealthy) {
    res.status(200).json({ status: 'healthy' });
  } else {
    res.status(503).json({ status: 'unhealthy' });
  }
});

app.get('/toggle-health', (req, res) => {
  isHealthy = !isHealthy;
  res.json({ status: isHealthy ? 'healthy' : 'unhealthy' });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
EOF

# B∆∞·ªõc 4: T·∫°o healthcheck.js
cat > healthcheck.js << 'EOF'
const http = require('http');

const options = {
  hostname: 'localhost',
  port: 3000,
  path: '/health',
  method: 'GET',
  timeout: 2000
};

const req = http.request(options, (res) => {
  if (res.statusCode === 200) {
    process.exit(0);  // Healthy
  } else {
    process.exit(1);  // Unhealthy
  }
});

req.on('error', () => {
  process.exit(1);  // Error
});

req.on('timeout', () => {
  req.destroy();
  process.exit(1);  // Timeout
});

req.end();
EOF

# B∆∞·ªõc 5: T·∫°o Dockerfile v·ªõi HEALTHCHECK
cat > Dockerfile << 'EOF'
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./

RUN npm ci --only=production

COPY . .

# HEALTHCHECK configuration
HEALTHCHECK --interval=10s --timeout=3s --retries=3 \
  CMD node healthcheck.js

EXPOSE 3000

CMD ["node", "server.js"]
EOF

# B∆∞·ªõc 6: Build image
docker build -t health-check-app:1.0 .
# Output: Successfully tagged health-check-app:1.0

# B∆∞·ªõc 7: Run container
docker run -d -p 3000:3000 --name health-app health-check-app:1.0
# Output: container ID

# B∆∞·ªõc 8: Verify container ch·∫°y
docker ps | grep health-app
# Output: health-app container

# B∆∞·ªõc 9: Xem logs
docker logs health-app
# Output: Server running on port 3000

# B∆∞·ªõc 10: Test health endpoint
curl http://localhost:3000/health
# Output: {"status":"healthy"}

# B∆∞·ªõc 11: Inspect container ƒë·ªÉ xem health status
docker inspect health-app | grep -A 10 "Health"
# Output:
# "Health": {
#   "Status": "healthy",
#   "FailingStreak": 0,
#   "Log": [...]
# }

# B∆∞·ªõc 12: Wait a bit v√† check l·∫°i
sleep 15
docker inspect health-app | grep -A 5 "Health"
# Output: Status v·∫´n "healthy"

# B∆∞·ªõc 13: Toggle health status (simulate unhealthy)
curl http://localhost:3000/toggle-health
# Output: {"status":"unhealthy"}

# B∆∞·ªõc 14: Check health status ngay l·∫≠p t·ª©c
docker inspect health-app | grep -A 5 "Health"
# Output: Status v·∫´n "healthy" (ch∆∞a update)

# B∆∞·ªõc 15: Wait cho health check ch·∫°y l·∫°i
sleep 15
docker inspect health-app | grep -A 5 "Health"
# Output: Status s·∫Ω thay ƒë·ªïi th√†nh "unhealthy"

# B∆∞·ªõc 16: Xem health check logs
docker inspect health-app | grep -A 20 "Health"
# Output: S·∫Ω th·∫•y log c·ªßa health checks

# B∆∞·ªõc 17: Toggle l·∫°i th√†nh healthy
curl http://localhost:3000/toggle-health
# Output: {"status":"healthy"}

# B∆∞·ªõc 18: Wait v√† verify
sleep 15
docker inspect health-app | grep -A 5 "Health"
# Output: Status s·∫Ω thay ƒë·ªïi th√†nh "healthy"

# B∆∞·ªõc 19: Stop container
docker stop health-app
# Output: health-app

# B∆∞·ªõc 20: Remove container
docker rm health-app
# Output: health-app

# B∆∞·ªõc 21: Verify cleanup
docker ps -a | grep health-app
# Output: (tr·ªëng)
```

**Ki·ªÉm tra k·∫øt qu·∫£:**
- ‚úÖ API ƒë∆∞·ª£c t·∫°o v·ªõi /health endpoint
- ‚úÖ Dockerfile c√≥ HEALTHCHECK
- ‚úÖ Image build th√†nh c√¥ng
- ‚úÖ Container ch·∫°y
- ‚úÖ Health status ƒë∆∞·ª£c track
- ‚úÖ Health status update khi thay ƒë·ªïi

**Bonus - Docker Compose v·ªõi health checks:**

```yaml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "3000:3000"
    healthcheck:
      test: ["CMD", "node", "healthcheck.js"]
      interval: 10s
      timeout: 3s
      retries: 3
      start_period: 5s
    restart: unless-stopped

  db:
    image: postgres:15
    environment:
      POSTGRES_PASSWORD: secret
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5
```

---

## üéì C·∫•p ƒê·ªô 3: N√¢ng Cao

### B√†i 11: Full-Stack MERN Application

**M·ª•c ti√™u:** Deploy complete MERN stack

**Y√™u c·∫ßu:**
1. MongoDB database
2. Express API
3. React frontend
4. Nginx reverse proxy
5. Docker Compose v·ªõi multiple networks
6. Health checks cho t·∫•t c·∫£ services
7. Persistent volumes

**C·∫•u tr√∫c:**
```
project/
‚îú‚îÄ‚îÄ docker-compose.yml
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îî‚îÄ‚îÄ src/
‚îú‚îÄ‚îÄ frontend/
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îî‚îÄ‚îÄ src/
‚îî‚îÄ‚îÄ nginx/
    ‚îî‚îÄ‚îÄ nginx.conf
```

**docker-compose.yml:**
```yaml
version: '3.8'

services:
  mongo:
    image: mongo:7
    restart: unless-stopped
    environment:
      MONGO_INITDB_ROOT_USERNAME: admin
      MONGO_INITDB_ROOT_PASSWORD: secret
    volumes:
      - mongo-data:/data/db
    networks:
      - backend
    healthcheck:
      test: echo 'db.runCommand("ping").ok' | mongosh localhost:27017/test --quiet
      interval: 10s
      timeout: 5s
      retries: 5

  backend:
    build: ./backend
    restart: unless-stopped
    environment:
      NODE_ENV: production
      MONGODB_URI: mongodb://admin:secret@mongo:27017/myapp?authSource=admin
      PORT: 5000
    depends_on:
      mongo:
        condition: service_healthy
    networks:
      - backend
      - frontend
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:5000/health"]
      interval: 30s
      timeout: 3s
      retries: 3

  frontend:
    build: ./frontend
    restart: unless-stopped
    depends_on:
      - backend
    networks:
      - frontend

  nginx:
    image: nginx:alpine
    restart: unless-stopped
    ports:
      - "80:80"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - frontend
      - backend
    networks:
      - frontend

volumes:
  mongo-data:

networks:
  frontend:
  backend:
```

---

### B√†i 12: Microservices Architecture

**M·ª•c ti√™u:** Build microservices system

**Y√™u c·∫ßu:**
1. API Gateway
2. User Service
3. Product Service
4. Order Service
5. Shared PostgreSQL
6. Shared Redis
7. Service discovery
8. Health checks

**Ki·∫øn tr√∫c:**
```
Client ‚Üí API Gateway ‚Üí User Service    ‚Üí PostgreSQL
                    ‚Üí Product Service  ‚Üí PostgreSQL
                    ‚Üí Order Service    ‚Üí PostgreSQL
                                       ‚Üí Redis
```

---

### B√†i 13: CI/CD Pipeline

**M·ª•c ti√™u:** Setup CI/CD v·ªõi Docker

**Y√™u c·∫ßu:**
1. T·∫°o GitHub Actions workflow
2. Build Docker image
3. Run tests trong container
4. Push image l√™n Docker Hub
5. Deploy v·ªõi Docker Compose

**.github/workflows/docker.yml:**
```yaml
name: Docker CI/CD

on:
  push:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Build Docker image
        run: docker build -t myapp:${{ github.sha }} .
      
      - name: Run tests
        run: docker run --rm myapp:${{ github.sha }} npm test
      
      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      
      - name: Push image
        run: |
          docker tag myapp:${{ github.sha }} myuser/myapp:latest
          docker push myuser/myapp:latest
```

---

### B√†i 14: Monitoring Stack

**M·ª•c ti√™u:** Setup monitoring v·ªõi Prometheus + Grafana

**Y√™u c·∫ßu:**
1. Prometheus ƒë·ªÉ collect metrics
2. Grafana ƒë·ªÉ visualize
3. Node Exporter cho system metrics
4. cAdvisor cho container metrics
5. Alert rules

**docker-compose.yml:**
```yaml
version: '3.8'

services:
  prometheus:
    image: prom/prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus-data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'

  grafana:
    image: grafana/grafana
    ports:
      - "3000:3000"
    environment:
      GF_SECURITY_ADMIN_PASSWORD: admin
    volumes:
      - grafana-data:/var/lib/grafana
    depends_on:
      - prometheus

  node-exporter:
    image: prom/node-exporter
    ports:
      - "9100:9100"

  cadvisor:
    image: gcr.io/cadvisor/cadvisor
    ports:
      - "8080:8080"
    volumes:
      - /:/rootfs:ro
      - /var/run:/var/run:ro
      - /sys:/sys:ro
      - /var/lib/docker/:/var/lib/docker:ro

volumes:
  prometheus-data:
  grafana-data:
```

---

### B√†i 15: Production Deployment

**M·ª•c ti√™u:** Deploy production-ready application

**Y√™u c·∫ßu:**
1. Multi-stage builds
2. Health checks
3. Resource limits
4. Logging configuration
5. Secrets management
6. Backup strategy
7. SSL/TLS
8. Auto-restart policies

**docker-compose.prod.yml:**
```yaml
version: '3.8'

services:
  web:
    build:
      context: .
      dockerfile: Dockerfile.prod
    restart: unless-stopped
    ports:
      - "443:443"
    environment:
      NODE_ENV: production
    env_file:
      - .env.production
    volumes:
      - ./ssl:/etc/ssl:ro
    healthcheck:
      test: ["CMD", "curl", "-f", "https://localhost/health"]
      interval: 30s
      timeout: 3s
      retries: 3
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 2G
        reservations:
          cpus: '1'
          memory: 1G
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
```

---

## üéØ Projects Th·ª±c T·∫ø

### Project 1: Blog Platform

**Stack:** Next.js + PostgreSQL + Redis

**Features:**
- User authentication
- CRUD posts
- Comments
- Image upload
- Caching v·ªõi Redis
- Full-text search

---

### Project 2: E-commerce API

**Stack:** Node.js + MongoDB + Redis + Elasticsearch

**Features:**
- Product catalog
- Shopping cart
- Order management
- Payment integration
- Search v·ªõi Elasticsearch
- Session v·ªõi Redis

---

### Project 3: Real-time Chat

**Stack:** Node.js + Socket.io + Redis + MongoDB

**Features:**
- Real-time messaging
- Multiple rooms
- User presence
- Message history
- File sharing

---

## üí° Tips

### Debugging

```bash
# Xem logs
docker compose logs -f service-name

# Exec v√†o container
docker compose exec service-name sh

# Inspect container
docker inspect container-name

# Xem resource usage
docker stats

# Network troubleshooting
docker network inspect network-name
```

### Performance

```bash
# Build v·ªõi cache
docker build --cache-from myapp:latest -t myapp:new .

# Prune unused resources
docker system prune -a

# Xem disk usage
docker system df
```

---

## üìö T√†i Li·ªáu Tham Kh·∫£o

- [Docker Samples](https://github.com/docker/awesome-compose)
- [Play with Docker](https://labs.play-with-docker.com/)
- [Docker Curriculum](https://docker-curriculum.com/)

---

## üìö B√†i Ti·∫øp Theo

üëâ [B√†i 17: Docker Cho C√°c Ng√¥n Ng·ªØ](./17-docker-cho-cac-ngon-ngu.md)

---

**Happy Practicing! üöÄ**

